2008 International Conference on Information Processing in Sensor Networks

Koala: Ultra-Low Power Data Retrieval in Wireless Sensor Networks

R˘azvan Mus˘aloiu-E.

Computer Science Dept.
Johns Hopkins University
razvanm@cs.jhu.edu

Chieh-Jan Mike Liang
Computer Science Dept.
Johns Hopkins University
cliang4@cs.jhu.edu

Andreas Terzis

Computer Science Dept.
Johns Hopkins University
terzis@cs.jhu.edu

Abstract

We present Koala, a reliable data retrieval system de-
signed to operate at permille (.1%) duty cycles, essential
for long term environmental monitoring networks. Koala
achieves these low duty cycles by letting the network’s
nodes sleep most of the time and reviving them through an
efﬁcient wake-up strategy whenever the gateway performs a
bulk data download. Unlike other systems which consume
energy to maintain consistent network state (e.g. routes,
sleep schedules, etc.) across the network’s nodes, Koala
maintains no persistent routing state on the motes. Instead,
a basestation calculates the network paths using reachabil-
ity information collected by the motes. The Flexible Control
Protocol (FCP), a protocol we developed, is then used to in-
stall this routing information on the network’s nodes. This
paradigm of operation not only eliminates the overhead of
maintaining routing state, but also signiﬁcantly reduces the
complexity of the networking code running on the motes.
Results from simulation and an actual implementation on
TinyOS 2 indicate that Koala can achieve very low duty cy-
cles under a wide range of download and network sizes.

1. Introduction

Routing protocols for long term data gathering applica-
tions, such as environmental monitoring, need to support
low duty cycles (<1%), reliably deliver collected measure-
ments, and operate unattended for long periods of time. In
response to these requirements, WSN networking stacks
employ techniques to coordinate the nodes’ sleep sched-
ules and maintain states at each of the network’s motes
(e.g.
[3].
In turn, implementing these techniques leads to network-
ing software with increased complexity running on resource
constrained motes. This complexity coupled with the unex-
pected and untested environment in which the network is
deployed can lead to failures. In fact, a number of deploy-
ments have reported failures related to networking code run-

routing entries, link quality information, etc.)

ning on the network’s motes [23, 24, 26].

In this paper we present a different approach to this prob-
lem that offers equivalent or better efﬁciency, while avoid-
ing most of the mote-side complexity associated with ex-
isting networking protocols. Speciﬁcally, our approach re-
quires motes to maintain no persistent networking state.
This feature not only lowers the complexity of the network-
ing code that runs on the motes, but also removes the over-
head of keeping that state consistent throughout the net-
work. This is a signiﬁcant advantage for low duty cycle
applications, for which control trafﬁc can be on par if not
higher than application trafﬁc.

The paper makes two main contributions: I. The de-
sign and development of the Flexible Control Protocol
(FCP), a signaling protocol used to install routing paths on
the network’s motes. A WSN gateway uses FCP to create
the multi-hop paths over which it downloads data from the
motes. FCP supports ephemeral paths that transmit a sin-
gle datagram and persistent paths that persist until explic-
itly torn down. Both paths can offer reliable transfers. II.
The design and development of Koala, a system for reli-
ably downloading bulk data that targets data gathering ap-
plications with no real-time requirements. Koala uses FCP
to establish network paths, coupled with Low Power Prob-
ing (LPP), an efﬁcient technique to wake up the network’s
motes before a download occurs. Furthermore, Koala lever-
ages the availability of multiple channels in 802.15.4 radios
to perform data downloads over different channels, thereby
minimizing overhearing costs.

Results from simulations and a testbed of 24 Tmote Sky
motes running TinyOS 2, show that the proposed approach
can achieve duty cycles of 0.2% or lower, in networks with
up to hundreds of motes. We show that channel switching
provides considerable beneﬁts, reducing download times by
up to ﬁve times. Moreover, users can select the desired
duty cycle by controlling how frequently they download
data from the network. Finally, our results indicate that LPP
can wake up a network of 24 motes in under 30 seconds.

This paper has seven sections.

In the section that fol-
lows we argue for a network-wide control plane and outline

978-0-7695-3157-1/08 $25.00 © 2008 IEEE
DOI 10.1109/IPSN.2008.10

421

the proposed architecture. Section 3 presents the design of
FCP, a signaling protocol used to establish network paths.
In Section 4 we present how FCP is used as part of the
Koala data gathering system. We evaluate Koala’s perfor-
mance through simulations and results from an early imple-
mentation in Section 5. Finally, we present related work in
Section 6 and close in Section 7 with a summary.

2. Overview

The motivating application for this work is environmen-
tal monitoring [15, 20, 26]. Environmental monitoring, at
its basic form, involves reliably gathering the measurements
from each of the network’s motes at a gateway. Further-
more, in order to observe long term spatial and temporal
trends, these networks need to be deployed for one or more
years and cover large geographic areas. These requirements
mean that such networks must have very low duty cycles
(∼ 0.1%) and support tens to hundreds of motes per gate-
way, deployed in sparse topologies.

In response to the dual requirement of energy-efﬁcient
operation and large scale, previous proposals have com-
bined multi-hop routing protocols with duty cycling [3].
These protocols synchronize the sleep schedules of neigh-
boring nodes, collect and disseminate link quality informa-
tion, and calculate routes through distributed min-cost rout-
ing algorithms. On the other hand, experience has shown
that implementing complex networking protocols on motes
can lead to unexpected failures in the ﬁeld [10, 24, 26].

These problems led us to investigate strategies for sim-
plifying the mote’s routing software. Generally speaking,
routing can be divided into the data and control planes.
The ﬁrst includes all the components necessary to forward
packets along a multi-hop path. To do so, it relies on a for-
warding table whose entries list the next-hop(s) on the path
towards a particular destination. This forwarding table is
maintained by the control plane which includes routing pro-
tocols that discover and select network paths.

We propose to decouple control and data planes at the
mote level, by implementing a network-wide routing control
plane. The majority of the functionality of this network-
wide plane is implemented at a centralized location (e.g.
a gateway) using information collected by the network’s
motes. This information is then used to calculate and dis-
seminate the end-to-end paths that motes will use.

The scenario shown in Figure 1 exempliﬁes our ap-
proach. The network’s motes in this example take measure-
ments and store them in local ﬂash. A gateway then period-
ically downloads the collected data. To do so, the gateway
ﬁrst instructs the nodes to collect information about their
neighbors. The gateway uses this information to calculate
high quality network paths, that is paths with consistently
low packet loss rate. The next step involves disseminat-

Figure 1. Example of application using the
Flexible Control Protocol (FCP).

ing path information to the network’s motes which subse-
quently use it to forward data back to the gateway. We use
the Flexible Control Protocol (FCP) for the data collection
and dissemination tasks. In this respect, FCP is used to in-
stall (forwarding) paths in the network and is therefore sim-
ilar to other signaling protocols, such as LDP [1].

Compared to routing protocols implemented at the mote
level, this approach provides multiple beneﬁts in addition to
reduced complexity. First, motes do not incur the overhead
of persistently maintaining routing state. Moreover, the
network-wide view provides the ability to perform other op-
timizations. For example, a node can establish two disjoint
paths to the same destination to improve reliability and/or
load balancing. At the same time, we require a centralized
entity to establish these network paths. Most deployments
however already include a gateway for connecting the WSN
to the Internet.

FCP can be combined with other protocols and network
services to implement custom applications. One such a ex-
ample is Koala, an ultra-low power system for reliable data
retrieval. Koala uses FCP to establish reliable network paths
for downloading sensor data. To achieve ultra-low duty cy-
cles Koala couples FCP with Low Power Probing (LPP), a
novel mechanism for waking up the network. Unlike Low
Power Listening (LPL), in which receivers periodically poll
the channel for long preambles from senders, nodes in LPP
send explicit probes and wake up if their probes are ac-
knowledged. Moreover, Koala leverages the availability of
multiple frequency channels in 802.15.4 radios to reduce
overhearing.

3. Flexible Control Protocol

Figure 2 represents the position of the Flexible Control
Protocol (FCP) relative to other protocols in the emerging
TinyOS 2 networking stack. Speciﬁcally, FCP sits directly
above the Active Message layer which offers the ability to
send unicast and broadcast messages to nodes within the
same broadcast domain. In turn, FCP provides upper layers

422

ACB1. PathEstablishmentMote PatchGatewayABC2. Data FlowPath TableOIDNHIIDPHC5A6Both path types can offer end-to-end reliability, mean-
ing that the destination will generate acknowledgments for
each of the packets it receives. Moreover, intermediate FCP
nodes will attempt to deliver the packets up to a maximum
number of times and notify the sender if the path is no
longer available.

3.2. Implementation

A major part of FCP relates to updating the entries in
nodes’ path tables during path establishment and termina-
tion. As Figure 1 illustrates, each entry in this table has four
entries: Previous Hop (PH), Incoming ID (IID), Next Hop
(NH), and Outgoing ID (OID). Packets that arrive from up-
stream node PH, carrying the IID identiﬁer are forwarded to
downstream node NH after their identiﬁer has been changed
to OID.

To establish an end-to-end path, the source ﬁrst con-
structs a PATH OPEN FCP control message which includes
the end-to-end route. This route is a sequence of addresses
corresponding to the network nodes that the message should
traverse. FCP is agnostic about the addresses used; the only
requirement is that such an address can be used to reach
a node that is within the same broadcast domain of the cur-
rent node. One can use MAC addresses but other identiﬁers,
such as TinyOS node identiﬁers can also be used.

The network path establishment phase starts after the
source node forwards the PATH OPEN message to the next
hop. Path IDs have local scope, having to be unique only
between the same pair of nodes. This means that the identi-
ﬁer space can be relatively small, reducing the overhead of
allocating and carrying path IDs. Once an outgoing ID has
been allocated, the PATH OPEN message can be forwarded
to the next downstream node until it reaches its ﬁnal destina-
tion. To reduce FCP’s memory footprint the path table has
an upper limit (the current implementation supports up to
32 concurrent connections). If a node’s path table is full, the
node replies with a PATH CLOSE message which uses the
source route included in the original PATH OPEN message.
Intermediate nodes that receive the PATH CLOSE message
remove the corresponding path entry before forwarding the
message upstream.

FCP uses link-layer retransmissions to improve the prob-
ability of successful packet delivery. We adopted this mech-
anism, used both for data and control packets, because it
has been shown that link-level retransmissions enhance the
reliability of WSN multi-hop paths considerably [21]. To
provide link-layer retransmissions, we leverage the hard-
ware acknowledgments that modern radio chips, such as
the CC2420 offer [25]. Compared to application-level ac-
knowledgments, hardware acknowledgements are faster be-
cause they are sent immediately after the radio receives the
original packets.

Figure 2. The Flexible Control Protocol (FCP)
and its relations to other protocols in the
emerging TinyOS 2 network protocol archi-
tecture.

the ability to send one or more messages across multi-hop
paths with or without end-to-end reliability.

Because motes do not keep any persistent routing state,
a network path1 must be established before it can be used to
carry trafﬁc. For this reason, FCP includes a path establish-
ment phase that installs entries on the path tables of each of
the nodes on the path. Nodes subsequently use these entries
to forward packets, until they are explicitly or implicitly re-
moved, thus relinquishing allocated resources.

3.1. FCP Services

Depending on whether paths are used to transmit one or
multiple data packets, FCP provides ephemeral and persis-
tent network paths.

Ephemeral Network Path. This service is equivalent to
a source route since the data packet carries the network path
it should follow in addition to the application’s data. Inter-
mediate nodes do not establish any state but rather forward
the packet based on the path encoded in it. This service is
useful when a node wants to send a short message, such as a
command, to another node in the network. It has the advan-
tage of not incurring the delay and the overhead associated
with establishing the path. On the other hand, the maximum
amount of application data that an ephemeral path can carry
is limited to a single radio packet, minus the space neces-
sary to store the path information.

Persistent Network Path. Unlike ephemeral paths, per-
sistent network paths must be established before they can be
used. This establishment phase requires intermediate nodes
to allocate entries on their path tables. These entries are
used to forward subsequent packets that do not carry source
routes. At the end of a successful establishment phase the
nodes at both ends of the path receive a path identiﬁer that
they use to forward trafﬁc in both directions.

1FCP network paths are analogous to virtual circuits or MPLS label-

switched paths (LSPs) but with no QoS attributes associated to them.

423

DripCTPActive MessageApplicationsFCPUnreliableEphemeral PathReliableUnreliableReliableEphemeral PathPersistent PathPersistent Path2

Dir

0

1

Packet Type

Ack

Req
Ack

3

4

5

6

7

Path Identiﬁer

Path Length / Sequence Numbers /

Error Number

FCP Port

Path (optional)

local ﬂash memory until a gateway extracts them. Such a
gateway does not have to be always present; rather it can
periodically join the network, establish network paths and
reliably retrieve data before it withdraws. This model of
operation matches well with the architecture described in
Section 2, as resources are not consumed to maintain per-
sistent routing state.

Figure 3. The FCP header.

4.1. Low Power Probing

If a packet can not be forwarded after ﬁve attempts, the
link is considered to have failed and the network path is ter-
minated. After all retransmission requests have failed, the
node upstream of the failed link returns a PATH CLOSE
message to the path’s source. We note that end-to-end ac-
knowledgments, generated by the destination for reliable
paths, are different from link-level acknowledgments and
retransmissions. Their purpose is to inform the source that
the destination has received its packets.

Network paths are terminated in two other cases. First,
each of the communication endpoints can explicitly termi-
nate an existing path by sending a PATH CLOSE control
message. Finally, FCP uses soft state and therefore interme-
diate nodes automatically remove table entries that have not
been recently used (the current timeout is set to 20 seconds).
If a node receives a data message carrying an unknown path
identiﬁer it responds with a PATH CLOSE message.

Figure 3 illustrates the FCP header, starting with the
Packet Type ﬁeld. Because network paths are bidirectional,
the Dir ﬁeld indicates the direction in which source routes
and path identiﬁers should be processed. The Path Identi-
ﬁer ﬁeld stores the identiﬁer used by the previous hop and
is used to insert an entry in the path table in the case of
PATH OPEN messages or to lookup the next hop for data
messages. The Req Ack and Ack ﬁelds are used to request
and return acknowledgments respectively. The next ﬁeld
is used as sequence number, acknowledgment number, er-
ror code, or as the length of the source route depending on
the packet type. The FCP Port ﬁeld indicates the receiving
FCP application or service at the destination node. Last, the
header may include an optional routing header which is a
list of node identiﬁers used as a source route.

4. Koala

As Figure 2 implies, FCP provides useful communica-
In practice, FCP will be coupled with

tion abstractions.
other protocols to develop a complete application.

We provide an example of this paradigm through Koala,
a system for reliably extracting bulk data from duty cycled
networks. We envision an environmental monitoring net-
work in which motes store collected measurements in their

Because current mote radios consume as much energy in
idle listening mode as when they transmit or receive [25],
nodes must maximize the time they keep their radios turned
off. This means that a mechanism is necessary to wake
up the network prior to a download operation. One poten-
tial solution would be for nodes to keep synchronized sleep
schedules as in [3, 28]. Doing so would however require
motes to maintain persistent network state (i.e. their neigh-
bors’ sleep schedules) which contradicts our philosophy of
simplifying mote-level networking code.

Low Power Listening (LPL), in which nodes periodically
sample the channel for signs of activity and transmitters
send long preambles to generate such activity, offers an ap-
pealing alternative for waking up non-synchronized nodes.
While initially presented in the context of bit-stream radios
([17]), LPL has been adopted to packet based radios, in
which case the preambles consist of a continuous stream
of packets [2].

LPL however was designed for waking up individual
nodes rather than the whole network, as Koala requires.
While using LPL in broadcast mode is possible, doing so re-
quires transmission of maximum length preambles, leading
to packet storms that impede the collection of neighborhood
data (described next). The underlying reason is that, unlike
the unicast case, the sender does not know when all intended
receivers have woke up. For this reason, it cannot terminate
the preamble’s transmission early. False negatives, situa-
tions in which a node fails to correctly detect a preamble,
represent an even bigger threat. While not a signiﬁcant issue
in the unicast case –a false negative can be detected due to
the lack of an acknowledgment, thus scheduling a retrans-
mission at the sender– missed detections can cause nodes to
completely miss the opportunity to wake up and participate
in a download.

Low Power Probing (LPP), a technique we developed,
addresses these problems by replacing passive channel
probing at the receiver with active probing. Speciﬁcally,
nodes periodically broadcast short packets requesting
acknowledgments. If such an acknowledgment is received,
the node wakes up and starts acknowledging other nodes’
probes, otherwise it goes back to sleep. Figure 4 provides
a graphical representation of LPL and LPP. LPP replaces
Clear Channel Assessment (CCA) samples at the receiver

424

Algorithm 2 Neighborhood Collection
procedure NEIGHBORHOODCOLLECTION(bs)

add ← INITQUEUE(bs)
while QUEUEEMPTY(add) = F alse do

node ←POPQUEUE(add)
path ←BUILDPATH(node, parent, bs)
r ←SENDNEIGHBORHOODREQ(node, path)
if r (cid:54)= Empty then

for each (n, rssi) in R do

UPDATENEIGHBORHOOD(n, rssi)
if INQUEUE(n, add) = F alse then

parent[n] ← node
r ←APPENDQUEUE(n)

procedure BUILDPATH(n, p, s)

r ←INITLIST(s)
while n (cid:54)= s do
r ←APPENDLIST(p[n])
n ← p[n]

return r

pendent of node density, and to be fair. To achieve these
properties, nodes select their beaconing intervals from an
exponential distribution and suppress their transmission if
they receive a beacon before their timer expires. The mem-
oryless property of the exponential distribution ensures fair-
ness, while suppression limits the total number of beacons.
Generating an exponential distribution from the uniform
distribution requires computing log(x) with x ∈ [0, 1]. In
practice, we found that approximating log(x) with the ﬁrst
term of its Taylor series

log(x) = (x − 1) − (x − 1)2

2

(x − 1)3

3

− (x − 1)4

4

. . .

+

produced satisfactory results.

The gateway uses unreliable persistent FCP paths to
collect the nodes’ neighborhood information every time it
wakes up the network. It does so by following the procedure
outlined in Algorithm 2. In summary, the gateway uses the
neighbor information it collects directly, to download the
neighborhoods of its immediate neighbors. Using this infor-
mation, the gateway extends its network knowledge by an-
other hop. Then, for each two-hop neighbor x, the gateway
selects the link between x and its existing one-hop neigh-
bors which has the highest RSSI value (say y). The path to
x then is built by extending the path to y. The advantage of
this approach is that new paths are always constructed by
extending existing high-quality paths. The algorithm termi-
nates after the gateway retrieves neighborhood information
from all the nodes.

4.3. Routing Path Selection

Routing path selection is a two-step process that starts
once the gateway retrieves neighborhood information from
all the network’s nodes. The gateway ﬁrst computes the
depth of each of the network’s nodes through a breadth-ﬁrst
search (BFS) of the collected network topology, in which all

Figure 4. A simpliﬁed representation of LPL
for packet-based radios and LPP. Preamble
and packet durations are not drawn to scale.

Algorithm 1 Lower Power Probing

procedure SLEEP(interval)

loop

TURNRADIOOFF()
DEEPSLEEP(interval)
TURNRADIOONWITHACKDISABLED()
r ← SENDPROBE()
if WASACKED(r) then

ENABLERADIOACKS()
return

with transmissions of short packets. In turn, this obviates
the need for long preambles thus reducing the level of
contention on the radio channel.

Algorithm 1 presents LPP in pseudo-code. Enabling and
disabling of acknowledgments is necessary to avoid false
positives when the probes of two or more nodes cause them
to wake each other up by mistake. When the SLEEP() pro-
cedure returns, the node keeps its radio on until the next
time the procedure is called. This procedure executes only
at the network’s motes. The wake up operation is initiated
by a gateway which enables its radio’s acknowledgements
and starts listening for probes from the network’s nodes.

4.2. Neighborhood Collection

While the gateway selects the routes in Koala, its deci-
sions are driven by information that the network’s motes
collect. Speciﬁcally, once awake, each node collects its
neighborhood by recording the identities of its neighbors
as well as the quality of its links from these neighbors, de-
ﬁned as the Received Signal Strength (RSSI) of the received
packets. These RSSI values are collected from the wake
up probes (and the acknowledgments to these probes) re-
ceived by the node’s neighbors. Furthermore, to acceler-
ate the neighborhood collection process, nodes send peri-
odic beacons which are also acknowledged, generating bi-
directional link information2.

We require two properties from the beaconing scheme:
to generate a bounded amount of trafﬁc overhead, inde-

2A node stops transmitting beacons once it participates in a download

operation.

425

                                                                                                 LPL SenderLPL ReceiverLPP SenderLPP ReceiverListeningProbe TransmissionPacketized PreambleAck TxPacket RxAck RxPacket TxCCA samplingListenlinks are initially considered equivalent. During the second
step, we compute a path from each of the network’s nodes
back to the gateway. We do this by starting from the se-
lected node and randomly following a good link towards a
neighbor that is closer to the gateway (i.e. at a higher level
of the BFS tree). In this context, good links are those with
RSSI values higher than -70 dBm. We use this threshold to
ensure that only stable links with low packet loss are used
for data downloads [13]. We randomly choose among good
links rather than selecting the best link to exercise multiple
links. This way, the load of retrieving data is distributed
more evenly among the network’s nodes.
If a path fails,
indicated by an FCP error, the gateway selects an alternate
path to download data from the current node.

4.4. Channel Switching

Once the network is active and the gateway has selected
the paths it will use, it starts to download data sequentially
from each of the network’s nodes. However, downloading
large blocks of data (∼ 100−200 KB) over multi-hop paths
can take from tens of seconds to minutes depending on link
conditions. Nodes that do not participate in the download
waste energy during this time. Therefore, it is desirable to
put these nodes to sleep. However, due to the way LPP
works, even if such nodes go to sleep, they will be awaken
because active nodes will acknowledge their probes.

To avoid these spurious wake ups the gateway instructs
all nodes on the current download path to switch to a dif-
ferent frequency channel3 before the download starts. Once
the download completes, the gateway instructs the nodes
to return to the common command channel. Both opera-
tions use reliable ephemeral FCP network paths. To switch
the path N1, N2, . . . Nk, the gateway initiates k sequential
channel switch requests starting from the node farthest from
it (i.e., Nk) and ending with N1. If all channel switch op-
erations are successful, the gateway initiates the download
operations. Because the same path is re-used to download
data from all k nodes, as soon as a download completes
the gateway asks the source node to return to the command
channel and go to sleep.

Algorithm 3 provides a formal description of both chan-
nel switch operations. While a number of failures can occur
during a channel switching operation, Koala will eventually
recover from all of them because motes return to the com-
mand channel if no FCP activity is detected within a certain
amount of time.

4.5. Data Download

The gateway uses reliable persistent FCP paths to down-
load the data from the network’s motes. The only remaining

3802.15.4 radios provide 16 non-overlapping frequency channels.

426

(cid:46) Last element is the top

Algorithm 3 Channel Switching

procedure PATHSWITCHING(path)

s ← INITSTACK()
t ← INITSTACK(path)
c ← RANDOMCHANNEL()
while STACKEMPTY(t) = F alse do
node ← POPSTACK(t)
r ← SENDCHSW(c, s)
if r = F ailed then

break

else

PUSHSTACK(s, node)

while STACKEMPTY(s) = F alse do

node ← POPSTACK(t)
if NEEDSDOWNLOAD(node) then

DOWNLOAD(s)

NODEDESWITCHING(s)

procedure NODEDESWITCHING(p)

for node in p do

if NEEDSDOWNLOAD(node) then

SENDCHSWWITHSLEEP(CmdChannel, p)
return

SENDCHSWITCH(CmdChannel, p)

challenge is to select the appropriate inter-packet interval
with which the source should inject packets to the network,
to avoid collisions with copies of its packets forwarded up-
stream. It is easy to show that in a download path in which
each node interferes only with its predecessor and succes-
sor, the source should inject one packet for every three time
slots (i.e. time necessary to transmit a single packet over a
single hop) to avoid collisions. However the correct inter-
packet delay is not known in the general case, because the
interference graph is not known.

One could derive the optimum delay OptDelay(m) for
paths of length m for the worst case scenario in which all
nodes interfere with each other.
In practice however de-
ployments are sparse and therefore this approach will pro-
duce suboptimal results. One way we can reduce this delay
bound is by using the collected neighborhood information.
To do so, for each node n on the download path p, we com-
pute P athN eighbors(n, p) which is the number of neigh-
bors that n has in p. The inter-packet delay can then be set
to the largest P athN eighbors() value since it represents
the maximum interference at any single hop on the path.

However, both approaches do not consider the impact of
hop-by-hop retransmissions in the face of packet loss. Such
retransmissions increase the time required for a packet to
“clear” an upstream hop and thus require larger and, more
importantly, dynamically adjustable inter-packet delays at
the source. For this reason, we opted for an alternative
approach in which the gateway uses the acknowledgments
that FCP generates to keep a running estimate of the path’s
round trip time (RTT). The source then injects a new packet
every RTT/2 seconds. The rational is that after RTT/2 sec-
onds the last packet most likely has exited the path, and it
is safe to send the next packet. Algorithm 4 presents the
full gateway’s logic. We acknowledge that this approach

Algorithm 4 Data Download

procedure DOWNLOAD(path)

start ← GETTIME()
r ← SENDNEIGBORHOODREQ(p)
rtt ← GETTIME()−start
if r = F ailed then

return

SENDDOWNLOADREQ(p, rtt/2)
repeat

until r = F ailedW LASTPACKET(r)

r ← RECEIVEDATADOWNLOAD()

is suboptimal, transmitting slower than the optimal sending
rate especially over paths with long RTTs. As part of our
future work we plan to address this limitation by exploring
the beneﬁts of using sophisticated rate control algorithms
such as the ones in [9, 16].

Once the gateway ﬁnishes downloading data from all the
intended nodes, it leaves the network or goes to sleep. The
rest of the network should also go to sleep when this hap-
pens. We achieve this behavior using the Drip dissemina-
tion protocol [12]. Speciﬁcally, the gateway periodically
(once every ﬁve seconds) disseminates monotonically in-
creasing values for key K. Each mote that receives an up-
dated K value resets its internal timer (set to 15 seconds).
If on the other hand, the mote does not receive a new value
before its timer expires, it goes to sleep.

5. Evaluation

5.1. Methodology

The metric we use to evaluate Koala’s performance is
the total time required to download a certain amount of data
from every network node. We chose this metric because
it represents the energy cost associated with Koala’s oper-
ation. To identify how this cost is distributed across the
different Koala phases described in Section 4, we further
divide the total time into the time necessary to wake up the
whole network and the time required to download data from
all of its nodes. Finally, we evaluate the efﬁciency of LPP
by comparing it with two versions of LPL included in the
TinyOS 2 distribution.

We evaluate Koala’s performance across different di-
mensions by varying the length of the LPP probing interval,
the size and the diameter of the network, and the amount of
data downloaded from each mote with and without channel
switching. This evaluation is based on a combination of re-
sults from simulation and a prototype implementation. We
use the TOSSIM simulator, which we enhance to simulate
all the components of the CC2420’s radio stack, other than
LPL. In this way, the simulation and the implementation use
identical FCP and Koala codebases.

TOSSIM requires the user to supply the gain of the links
used in the simulated topologies. We compute these gains

Figure 5. Examples of random topologies
with ten and forty nodes.

Figure 6. CDFs of link RSSIs for the 24-node
testbed and randomly generated topology.

using the Log Distance Path Loss model with a path expo-
nent of four, to approximate challenging signal propagation
environments. Furthermore, we model noise using the CPM
model recently added to TOSSIM [11]. All simulations use
the meyer-heavy.txt noise trace from [11].

We generate different simulation topologies using an it-
erative approach. First, we place the gateway in the mid-
dle of the ﬁeld. We then incrementally add motes to the
topology by selecting an existing mote and generating a
new mote location according to a two-dimensional uniform
distribution, such that the new node is within communi-
cation range (RSSI > −80 dBm). This requirement en-
sures that the topology is connected, while still having some
lossy links. Moreover, to avoid clustering of multiple nodes
around the gateway, we impose a minimum distance cor-
responding to a RSSI of -60 dBm between any two nodes.
This second requirement reﬂects the reality that nodes will
not be placed very close to each other, to maximize spatial
coverage. Figure 5 depicts two sample topologies generated
through this procedure.

While simulations allow us to study different network
scales and system parameters, testbed experiments provide
full realism. For this reason, we use a testbed of 24 Tmote
Sky motes, deployed throughout a single ﬂoor of an of-
ﬁce building. The testbed’s topology is approximately lin-
ear, matching the building’s layout. Figure 6 compares the
CDFs of the link RSSI values from the testbed and a 25-
node simulated topology.

427

 0 20 40 60 80 100 0 20 40 60 80 10010 nodes 0 20 40 60 80 100 0 20 40 60 80 10040 nodes 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1-100-90-80-70-60-50-40-30LinksRSSI [dBm]Testbed vs. simulated topologiesTestbed (24 nodes)Simulation (25 nodes)5.2. LPP vs. LPL

We compare two LPL implementations included in
TinyOS 2.x with LPP by measuring the energy consumed
during a single passive or active probe. To do so, we
measure the duration and the current draw during each
operation by recording the voltage drop on a 10 Ω resistor
placed in series with a Tmote Sky mote. Figure 7 presents
one such experiment, while Table 1 summarizes the results
over all experiments. The time intervals included in that
table correspond to the total duration of each operation
including the time necessary to turn on the radio.

Due to the signiﬁcant changes in the LPL implementa-
tions in TinyOS 2.x4, we tested not only the one included
in the current release (2.0.2) but also two versions from the
previous release (2.0.1). While LPL sampling is in theory
very fast (a CCA sample requires 128 µsec on the CC2420),
in practice implementations sample the medium multiple
times to increase robustness to random noise and transmis-
sion gaps. These gaps are generated because preambles in
the case of packet-based radios, such as the CC2420, are
generated by repeatedly transmitting the same packet. Fur-
thermore, XMAC [2] (which LPL 2.0.2 and LPL 2.0.1 Ack
in Table 1 are modeled after), introduces longer gaps be-
tween successive packet preambles, allowing the intended
receiver to transmit an acknowledgment. From the re-
ceiver’s perspective, the main difference between the three
versions, as Table 1 indicates, is the amount of time that the
radio’s CCA circuit is used in order to reliably detect the
presence of a sender’s preamble.

We note that in the case of LPL we exclude the cases in
which a 100 ms timeout was triggered. Such a timeout oc-
curs when the probe mistakenly claims that there is channel
activity but no packet arrives within 100 ms. During this
time the node keeps its radio on waiting for a packet trans-
mission. In our testbed these timeouts occurred in 14% of
all the LPL probe experiments we performed.

Even with this unfavorable comparison, LPP is on the
average only 32% more expensive than the current version
of LPL. This is to be expected since LPP transmits an actual
packet, while LPL only uses the radio’s CCA circuit. This
difference also underlies the larger variability of LPP oper-
ations compared to LPL. Nonetheless, the impact of LPP’s
higher cost can be managed by adjusting the probing inter-
val, as Figure 8 indicates.

5.3. Wake-up Performance

Several factors determine the time required to wake up
every node in the network: the size of the network, its topol-
ogy, and the probing frequency. We evaluate the impact

4A comprehensive description and evaluation of the major LPL ver-

sions implemented in TinyOS 2 can be found in [14].

Figure 7. Current consumption during a LPL
(TinyOS 2.0.2) and a LPP operation.

Figure 8. Node duty cycles for LPP and LPL
with varying probing intervals.

of the ﬁrst two factors through linear topologies with vary-
ing number of nodes, while keeping the distance between
neighboring nodes constant at 10 feet. For the propagation
model and the noise trace we use, this distance means that
on average each node can communicate reliably with its two
closest neighbors, while rare transmissions from as far as
ten hops away will be successful. LPP probes are sent ev-
ery one second.

The upper line in Figure 9 represents the average amount
of time to wake up the whole network, while the lower line
represents the average amount of time a node waits once
awake for the whole network to wake up. Thereby, the dif-
ference between the two lines represents the average time
necessary to wake up a node. As expected, the wake-up
time increases linearly with the network’s diameter.

We also study the effect of increasing the probing inter-

Mechanism

LPP
LPL 2.0.2
LPL 2.0.1 Ack
LPL 2.0.1 NoAck

Time (ms)
stdev
2.71
0.10
0.07
0.08

increase
+26%

-34%
-66%

mean
20.82
16.46
10.81
5.46

Energy (mW)

mean
8.73
6.58
3.75
0.43

stdev
1.488
0.016
0.003
0.002

increase
+32%

-77%
-97%

Table 1. Summary statistics for LPL and LPP.

428

 0 5 10 15 20 0 5 10 15 20 25 30 35 40Current [mA]Time [ms]LPPLPL (2.0.2) 0 0.05 0.1 0.15 0.2 0.25 0.3 0.35 0.4 0.45 10 20 30 40 50 60Duty Cycle [%]Probing interval [s]LPPLPL (2.0.2)LPL (2.0.1, ACK)LPL (2.0.1, NO ACK)Figure 9. Network wake-up times and node
waiting time as a function of the size of a lin-
ear network. Lines correspond to the best-ﬁt
linear regressions of the experimental data.

Figure 11. Average active time, with and with-
out channel switching, for the gateway and
the members of a 25-node random topology
as a function of download size.

it provides duty cycle of 0.1% (see Fig.8).

First, we vary the amount of data retrieved during each
download operation for a random topology of 25 nodes. As
Figure 11 illustrates, the importance of channel switching
becomes evident for download sizes larger than 32 KB. For
these sizes, it pays off to switch the nodes to a different
channel before doing a download because the remaining
nodes can go to sleep while the download is in progress.
Moreover, channel switching happens fast. We measured
that on average it takes 96.34 ms to switch all the nodes on
a download path for simulated linear topologies of up to 100
nodes, and 230 ms on our testbed.

While channel switching is beneﬁcial for individual net-
work nodes, it also increases the total time to download data
from the whole network. The reason is that the gateway
must wake up the remaining nodes and (re)collect neigh-
borhood information and establish routing paths, after it ﬁn-
ishes a download operation. This additional time is repre-
sented in Figure 11 as the difference between the total time
the gateway is active when channel switching is used and
the time required when channel switching is disabled (in
which case the gateway as well as the motes keep their ra-
dio on for the same amount of time).

Next, we investigate the effect that network size has on
the time that node radios are active. Figure 12 presents the
per-node, as well as the gateway time for linear topologies
ranging from 10 to 100 nodes. Inter-packet delay varies in
these cases from 10.77 ms to 37.35 ms for the 100-node
topologies. While some packets were lost using these de-
lays, the average loss rate was very low (∼ 3 × 10−5). It
is evident that download time grows linearly with network
size. At the same time, downloads take longer in long linear
networks, requiring the gateway to be active for up to two
hours. In practice however, we do not envision that Koala
will be used in such long networks. Furthermore, multiple

Figure 10. Relation between the network and
node wake-up times and LPP probing interval
for linear networks.

val on network wake up time using the same linear topolo-
gies. As Figure 10 suggests, while increasing the probing
interval reduces a node’s duty cycle (cf. Fig.8) it also causes
network wake-up times in the order of minutes thereby neu-
tralizing or even negating the energy savings associated
with the smaller duty cycles.

Finally, we measure the time to wake up all the nodes
in our testbed. To do so, we randomize each node’s boot
time to ensure that they wake up at different times and use
one second probing intervals. Given these conditions, the
average network wake-up time was 29 seconds.

5.4. Data Download

Next, we investigate the amount of time necessary to
download data using Koala. We evaluate the potential ben-
eﬁts of channel switching and investigate the effects that
download and network size have on download time. In all
experiments we use LPP probing interval of 20 sec, because

429

 0 10 20 30 40 50 60 70 80 90 0 20 40 60 80 100 120 140 160Waiting time [sec]Number of nodesAverageTotal 0 5 10 15 20 25 30 0 10 20 30 40 50 60Waiting time [min]Inter-probing interval [sec]Average, 60 nodesTotal, 60 nodes, MaxAverage, 20 nodesTotal, 20 nodes 0 10 20 30 40 50 0 50 100 150 200 250 300 350 400 450 500 550Radio-on time [minutes]Data Size [kilobytes]Without Channel SwitchingWith Channel SwitchingWith Channel Switching (gateway)ing neighborhood information and installing routes, and the
cost of downloading data. This is the reason why all duty
cycles start at 0.1%, because this the cost of running LPP
alone. Figure 13 also illustrates the duty cycles achieved
by Dozer, the most efﬁcient data gathering protocol to this
date [3]. Speciﬁcally, the two vertical lines represent the
amount of data Dozer nodes generate5, while the horizontal
line represents the lower duty cycle reported in [3].

While the last result suggests that Koala can achieve
ultra-low duty cycles, we want to better understand how ef-
ﬁcient it is and whether it can be further improved. We do
so by presenting network-wide statistics across 20 randomly
generated topologies with 25 nodes. The download size in
all cases is 128 KB. The top chart of Figure 14 presents the
total time that nodes keep their radios on, including time
spent to wake up the network (including neighborhood col-
lection and route setup), download data, and stay idle lis-
tening. The second chart shows the amount of time nodes
transmit their own data, while the third chart shows the
amount of time nodes transmit their own data as well as the
data of other nodes. The variation in download time is due
to the different inter-packet delays various nodes use, while
the outliers in the amount of time spent on the download
channel correspond to nodes which are close to the gateway
and thus spend more time acting as relays.

Overall, the results show that nodes spend 60% of their
time in the download channel forwarding data on behalf of
other nodes. Furthermore, nodes spend 85% of their active
time idle listening. This time includes the time nodes wait
to go back to sleep while the gateway downloads data from
other nodes and the time required to wake up the network.
This high overhead can be reduced in two ways: ﬁrst, by
using a faster LPP probing rate once the network is awake
and second, by optimizing the order in which the gateway
performs the downloads.

Finally, the two charts on the right side of Figure 14
present corresponding results across ﬁve testbed runs. Total
download times in this case are not only higher, due to the
testbed’s harsher operating conditions, but also more vari-
able due to intermittent interference.

6. Related Work

Dozer [3] is the ﬁrst data gathering protocol that achieves
permille (∼0.1%) duty cycles. While Koala shares the same
goal, it achieves it using a radically different approach.
Unlike Dozer, Koala does not require synchronized sleep
schedules, nor does it require motes to persistently main-
tain routing trees. This strategy conserves energy, but on

5Dozer nodes transmit one packet every 120 seconds, corresponding to
720 packets per day. If payload size ranges from 10 to 100 bytes, then
nodes generate between 7,200 and 72,000 bytes per day.

Figure 12. Average active time for the gate-
way and the members of a variable length lin-
ear network. The download size is 128 KB
and channel switching is used.

Figure 13. Overall duty cycle as a function of
the per-node data acquisition rate. The gray
area corresponds to the acquisition rates and
duty cycle reported by Dozer [3].

gateways can be used to reduce the network’s diameter.

Koala provides the ﬂexibility of running the network at
different duty cycles by adjusting the amount of data re-
trieved during each download operation. Intuitively, down-
loading larger blocks of data in a single operation is more
efﬁcient than using multiple smaller operations because the
constant overhead of waking up the network is incurred
only once. On the other hand, one needs to wait until the
motes have collected the appropriate amount of data before
a download operation can occur. Therefore, the data re-
trieval latency is a function of the data acquisition rate and
the download size.

Figure 13 illustrates these trade-offs by presenting the
overall duty cycles achieved by different download sizes as
a function of the amount of data nodes collect per day. The
computed duty cycles include all the system costs, includ-
ing the cost of (repeatedly) waking up the network, collect-

430

 0 20 40 60 80 100 120 10 20 30 40 50 60 70 80 90 100Radio-on time [minutes]Number of nodesSensing node (average)Gateway 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 0 20000 40000 60000 80000 100000 120000Duty-cycle [%]Data rate [bytes/day/node]512KB352KB192KB128KB96KB64KB32KBtions and simplifying the decisions that sensing nodes must
make, it is possible to implement functionality equivalent
to existing mote-centric applications, while simplifying the
mote-level code. While Koala shares Tenet’s goal of sim-
plifying the mote-level code, it does not constrain the ap-
plication code that motes can run.
Instead, it replaces
mote-centric routing protocols (e.g. MintRoute [27]) with
gateway-driven communications paths.

SP [18] and the Chameleon/Rime stack [4] represent
two proposals for organizing the WSN network architec-
ture. Even-though FCP implements some of the function-
ality covered by SP (e.g., neighborhood management), they
address different problems. FCP is concerned with estab-
lishing end-to-end paths, while SP is concerned with com-
munications within the same broadcast domain. As a matter
of fact, FCP can be implemented on top of SP. FCP is sim-
ilar with the Rime stack but due to its tight integration with
Chameleon, Rime has a much more specialized role com-
pared to FCP.
Dutta et al.

recently argued about the beneﬁts of dis-
connected operation in data gathering sensor networks [5].
Koala presents the ﬁrst architecture that realizes the bene-
ﬁts theorized in [5]. Finally, a number of proposals have
proposed decoupling routing from forwarding in the con-
text of the Internet [6, 8, 19]. Their focus is different: they
address the scalability and consistency of the routing infor-
mation, while our goal is to simplify the mote’s networking
stack and minimize the overhead associated with maintain-
ing networking state.

7. Summary

We present Koala, a system for reliable bulk data re-
trieval from duty-cycled networks that represents a differ-
ent point in the design space. We argue that decoupling
the routing control and data planes simpliﬁes the motes’
software and lowers the maintenance overhead. Koala cou-
ples FCP with efﬁcient protocols for network-wide wake up
and downloading bulk data, producing an end-to-end sys-
tem that can achieve ultra-low duty cycles.

Acknowledgements

We extend our gratitude to our shepherd, Philip Levis,
and the anonymous reviewers for their insightful comments
and their help in improving this paper.

This research was supported in part by NSF grant CNS-
0546648 and by the U.S. Department of Homeland Secu-
rity (Grant Number N00014-D6-1-0991) through a grant
awarded to the National Center for the Study of Prepared-
ness and Critical Event Response (PACER) at the Johns
Hopkins University. Any opinions, ﬁnding, conclusions or

Figure 14. Activity statistics 128 KB down-
loads across 20 random topologies of 25
nodes.

the other hand, the synchronization allows Dozer to contin-
uously inform the gateway about the network’s health and
also deliver the measurements with a much smaller delay.
Centroute [22] introduced the concept of having a central
node use source routes to control the routing decision in a
network. However, Centroute is customized for data gath-
ering applications, while FCP provides more general com-
munication abstractions. Furthermore, Koala couples FCP
with an efﬁcient mechanism for waking up a network of
non-synchronized duty-cycled nodes. Flush [9] recently
proposed a protocol to efﬁciently transfer bulk data un-
der different network scales. Unlike Flush, Koala includes
mechanisms for network-wide wake up and for determin-
ing and establishing multi-hop network paths. At the same
time, Koala would beneﬁt by the rate control algorithms de-
veloped in Flush and RCRT [16].

Tenet represents a tiered architecture in which low-tier
nodes (e.g., motes) are driven by master nodes to perform
It showed that by constraining the ac-
simple tasks [7].

431

200400600800The amount of time with the radio onTopology [#]Time [sec]4006008001000TestbedRun [#]Time [sec]20406080100Download timeTopology [#]Time [sec]50100150200TestbedRun [#]Time [sec]0100300500700The amount of time on the download channelsTopology [#]Time [sec]HelpOverhead5060708090Help and OverheadPercentagerecommendations expressed in this publication are those of
the authors and do not represent the policy or position of the
Department of Homeland Security and the NSF.

References

[1] L. Andersson, P. Doolan, N. Feldman, A. Fredette, and

B. Thomas. LDP Speciﬁcation. RFC 3036, Jan. 2001.

[2] M. Buettner, G. Yee, E. Anderson, and R. Han. X-MAC:
A Short Preamble MAC Protocol for Duty-Cycled Wireless
Sensor Networks. In Proceedings of the 4th ACM Confer-
ence on Embedded Sensor Systems (SenSys), 2006.

[3] N. Burri, P. von Rickenbach, and R. Wattenhofer. Dozer:
ultra-low power data gathering in sensor networks. In Pro-
ceedings of the 6th international conference on Information
processing in sensor networks (IPSN), 2007.

[4] A. Dunkels, F. ¨Osterlind, and Z. He. An Adaptive Com-
munication Architecture for Wireless Sensor Networks. In
Proceedings of the 5th ACM Conference on Embedded Net-
worked Sensor Systems (SenSys), Nov. 2007.

[5] P. Dutta, D. Culler, and S. Shenker. Procrastination Might
Lead to a Longer and More Useful Life. In Proceedings of
HotNets-VI, 2007.

[6] N. Feamster, H. Balakrishnan, J. Rexford, A. Shaikh, and
J. van der Merwe. The case for separating routing from
routers. In Proceedings of the ACM SIGCOMM workshop
on Future Directions in Network Architecture, Aug. 2004.

[7] O. Gnawali, B. Greenstein, K.-Y. Jang, A. Joki, J. Paek,
M. Vieira, D. Estrin, R. Govindan, and E. Kohler. The
TENET Architecture for Tiered Sensor Networks. In Pro-
ceedings of the ACM Sensys Conference, Nov. 2006.

[8] A. Greenberg, G. Hjalmtysson, D. A. Maltz, A. Meyers,
J. Rexford, G. Xie, H. Yan, J. Zhan, and H. Zhang. A
clean slate 4D approach to network control and manage-
ment. ACM SIGCOMM Computer Communications Review,
Oct. 2005.

[9] S. Kim, R. Fonseca, P. Dutta, A. Tavakoli, P. L. David Culler,
S. Shenker, and I. Stoica. Flush: A Reliable Bulk Transport
Protocol for Multihop Wireless Networks. In Proceedings
of ACM Sensys 2007, Nov. 2007.

[10] K. Langendoen, A. Baggio, and O. Visser. Murphy loves
potatoes: experiences from a pilot sensor network deploy-
ment in precision agriculture. In Proceedings of the Parallel
and Distributed Processing Symposium (IPDPS), Apr. 2006.
[11] H. Lee, A. Cerpa, and P. Levis. Improving Wireless Sim-
In Proceedings of the
ulation Through Noise Modeling.
Sixth International Conference on Information Processing
in Wireless Sensor Networks (IPSN’07), 2007.

[12] P. Levis and G. Tolle.

TEP 118 Dissemination.
Available at http://www.tinyos.net/tinyos-2.
x/doc/html/tep118.html.

[13] S. Lin, J. Zhang, G. Zhou, L. Gu, J. A. Stankovic, and T. He.
ATPC: Adaptive Transmission Power Control for Wireless
Sensor Networks. In SenSys ’06: Proceedings of the 4th in-
ternational conference on Embedded networked sensor sys-
tems, pages 223–236, New York, NY, USA, 2006. ACM.

[14] D. Moss and P. Levis. BoX-MACs: Exploiting Physical and

Link Layer Bounrdaries in Low-Power Networking.

432

[15] R. Mus˘aloiu-E., A. Terzis, K. Szlavecz, A. Szalay, J. Cogan,
and J. Gray. Life Under your Feet: A Wireless Sensor Net-
work for Soil Ecology. In Proceedings of the 3rd EmNets
Workshop, May 2006.

[16] J. Paek and R. Govindan. Rate-Controlled Reliable Trans-
port for Sensor Networks. In Proceedings of the ACM Sen-
sys, 2007.

[17] J. Polastre, J. Hill, and D. Culler. Versatile Low Power Me-
In SenSys ’04:
dia Access for Wireless Sensor Networks.
Proceedings of the 2nd international conference on Embed-
ded networked sensor systems, pages 95–107, New York,
NY, USA, 2004. ACM.

[18] J. Polastre, J. Hui, P. Levis, J. Zhao, D. Culler, S. Shenker,
and I. Stoica. A Unifying Link Abstraction for Wireless Sen-
sor Networks. In Proceedings of ACM SenSys, Nov. 2005.

[19] J. Rexford, A. Greenberg, G. Hjalmtysson, D. A. Maltz,
A. Myers, G. Xie, J. Zhan, and H. Zhang. Network-wide
decision making: Toward a wafer-thin control plane. In Pro-
cedings of the ACM SIGCOMM HotNets Workshop, Nov.
2004.

[20] L. Selavo, A. Wood, Q. Cao, T. Sookoor, H. Liu, A. Srini-
vasan, Y. Wu, W. Kang, J. Stankovic, D. Young, and
J. Porter. LUSTER: Wireless Sensor Network for Envi-
ronmental Research. In Proceedings of the 5th ACM Con-
ference on Embedded Networked Sensor Systems (SenSys),
Nov. 2007.

[21] F. Stann and J. Heidemann. RMST: Reliable Data Transport
In Proceedings of the First Interna-
in Sensor Networks.
tional Workshop on Sensor Net Protocols and Applications,
Apr. 2003.

[22] T. Stathopoulos, L. Girod, J. Heidemann, and D. Estrin.
Mote herding for tiered wireless sensor networks. Technical
Report CENS-TR-58, University of California, Los Ange-
les, Center for Embedded Networked Computing, December
2005.

[23] R. Szewczyk, A. Mainwaring, J. Anderson, and D. Culler.
An Analysis of a Large Scale Habitat Monitoring Applica-
tion. In Proceedings of SenSys 2004, Nov. 2004.

[24] R. Szewczyk, J. Polastre, A. Mainwaring, and D. Culler.
Lessons from a Sensor Network Expedition. In Proceedings
of the 1st European Workshop on Wireless Sensor Networks
(EWSN ’04), Jan. 2004.

[25] Texas Instruments. 2.4 GHz IEEE 802.15.4 / ZigBee-ready
RF Transceiver. Available at http://www.chipcon.
com/files/CC2420_Data_Sheet_1_3.pdf, 2006.
[26] G. Tolle, J. Polastre, R. Szewczyk, N. Turner, K. Tu,
P. Buonadonna, S. Burgess, D. Gay, W. Hong, T. Dawson,
and D. Culler. A Macroscope in the Redwoods. In Proceed-
ings of the Third ACM Conference on Embedded Networked
Sensor Systems (SenSys), Nov. 2005.

[27] A. Woo, T. Tong, and D. Culler. Taming the underlying
challenges in reliable multihop wireless sensor networks. In
Proceedings of ACM Sensys 2003, 2003.

[28] W. Ye, J. Heidemann, and D. Estrin. An Energy-Efﬁcient
MAC Protocol for Wireless Sensor Networks. In Proceed-
ings of IEEE INFOCOM 2002, 2002.

